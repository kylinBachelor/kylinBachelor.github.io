{"content":"<h4 id=\"rocketmq概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq概述\"><span>RocketMQ概述</span></a></h4>\n<p>官网：https://rocketmq.apache.org/zh/docs/domainModel/01main</p>\n<p>RocketMQ中消息的生命周期分为三部分：消息生产，消息存储，消息消费。</p>\n<p>生产者生产消息并发送至RocketMQ服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。</p>\n<h5 id=\"消息生产者-producer\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息生产者-producer\"><span>消息生产者（Producer）</span></a></h5>\n<p>用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级、匿名、无身份的。</p>\n<h5 id=\"消息存储\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息存储\"><span>消息存储</span></a></h5>\n<ul>\n<li>\n<p>主题（Topic）</p>\n<p>消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。</p>\n</li>\n<li>\n<p>队列（MessageQueue）</p>\n<p>消息传输和存储的实际单元容器，类比于其它消息队列中的分区。RocketMQ通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特性。</p>\n</li>\n<li>\n<p>消息（Message）</p>\n<p>最小的传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变</p>\n</li>\n</ul>\n<h5 id=\"消息消费\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息消费\"><span>消息消费</span></a></h5>\n<ul>\n<li>\n<p>消费分组（ConsumerGroup）</p>\n<p>RocketMQ发布订阅模型中定义的独立的消费身份，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持<strong>消费逻辑和配置一致</strong>，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p>\n</li>\n<li>\n<p>消费者（Consumer）</p>\n<p>消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</p>\n</li>\n<li>\n<p>订阅关系（Subscription）</p>\n<p>发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p>\n<p>RocketMQ的订阅关系除过滤表达式之外都是持久化的，即服务器重启或请求断开，订阅关系依然保留。</p>\n</li>\n</ul>\n<h4 id=\"rocketmq基本概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq基本概念\"><span>RocketMQ基本概念</span></a></h4>\n<ol>\n<li>\n<p>消息（Message）</p>\n<p>消息是消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>\n</li>\n<li>\n<p>主题（Topic）</p>\n<p>Topic表示一类消息的集合，每个主题必须包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消费订阅的基本单位。topic:message  1:n,  message:topic: 1:1</p>\n<p>一个生产者可以同时发送多种topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种topic的消息。producer:topic   1:n, consumer:topic  1:1</p>\n</li>\n<li>\n<p>标签（Tag）</p>\n<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一主题下设置不同的标签，标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提 供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>\n</li>\n<li>\n<p>队列</p>\n<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一 个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>\n<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。<strong>一个Queue中的消息不允许同 一个消费者组中的多个消费者同时消费。</strong></p>\n</li>\n<li>\n<p>消息标识</p>\n<p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息到达Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>\n<ul>\n<li>\n<p>msgId：由producer端生成，</p>\n<p>其生成规则为： producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p>\n</li>\n<li>\n<p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的 偏移量）</p>\n</li>\n<li>\n<p>key：由用户指定的业务相关的唯一标识</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"rocketmq四部分\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq四部分\"><span>RocketMQ四部分</span></a></h4>\n<ol>\n<li>\n<p>Producer</p>\n<p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投 递，投递的过程支持快速失败并且低延迟。</p>\n<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>\n</li>\n<li>\n<p>Consumer</p>\n<p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务 处理。</p>\n<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消 费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现 负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注 意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可 以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>\n</li>\n<li>\n<p>Name Server</p>\n<p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>\n<p>主要包括两个功能：</p>\n<ul>\n<li><strong>Broker管理</strong>：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测 机制，检查Broker是否还存活。</li>\n<li><strong>路由信息管理</strong>：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列 信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消 息的投递和消费。</li>\n</ul>\n<p>路由注册：</p>\n<p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各 个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在 Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在 NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。</p>\n</li>\n<li>\n<p>Broker</p>\n<p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从 生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括 消费者组消费进度偏移offset、主题、队列等。</p>\n</li>\n</ol>\n","env":{"base":"/","filePath":"C:/Users/kylinBachelor/Desktop/kylinBachelor.github.io/docs/notes/MQ/RocketMQ/RocketMQ初识/index.md","filePathRelative":"notes/MQ/RocketMQ/RocketMQ初识/index.md","frontmatter":{"title":"RocketMQ初识","aliases":null,"tags":["RocketMQ MQ"],"description":"RocketMQ初识","createTime":"2024/11/30 14:15:41","draft":false},"sfcBlocks":{"template":{"type":"template","content":"<template><h4 id=\"rocketmq概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq概述\"><span>RocketMQ概述</span></a></h4>\n<p>官网：https://rocketmq.apache.org/zh/docs/domainModel/01main</p>\n<p>RocketMQ中消息的生命周期分为三部分：消息生产，消息存储，消息消费。</p>\n<p>生产者生产消息并发送至RocketMQ服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。</p>\n<h5 id=\"消息生产者-producer\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息生产者-producer\"><span>消息生产者（Producer）</span></a></h5>\n<p>用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级、匿名、无身份的。</p>\n<h5 id=\"消息存储\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息存储\"><span>消息存储</span></a></h5>\n<ul>\n<li>\n<p>主题（Topic）</p>\n<p>消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。</p>\n</li>\n<li>\n<p>队列（MessageQueue）</p>\n<p>消息传输和存储的实际单元容器，类比于其它消息队列中的分区。RocketMQ通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特性。</p>\n</li>\n<li>\n<p>消息（Message）</p>\n<p>最小的传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变</p>\n</li>\n</ul>\n<h5 id=\"消息消费\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息消费\"><span>消息消费</span></a></h5>\n<ul>\n<li>\n<p>消费分组（ConsumerGroup）</p>\n<p>RocketMQ发布订阅模型中定义的独立的消费身份，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持<strong>消费逻辑和配置一致</strong>，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p>\n</li>\n<li>\n<p>消费者（Consumer）</p>\n<p>消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</p>\n</li>\n<li>\n<p>订阅关系（Subscription）</p>\n<p>发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p>\n<p>RocketMQ的订阅关系除过滤表达式之外都是持久化的，即服务器重启或请求断开，订阅关系依然保留。</p>\n</li>\n</ul>\n<h4 id=\"rocketmq基本概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq基本概念\"><span>RocketMQ基本概念</span></a></h4>\n<ol>\n<li>\n<p>消息（Message）</p>\n<p>消息是消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>\n</li>\n<li>\n<p>主题（Topic）</p>\n<p>Topic表示一类消息的集合，每个主题必须包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消费订阅的基本单位。topic:message  1:n,  message:topic: 1:1</p>\n<p>一个生产者可以同时发送多种topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种topic的消息。producer:topic   1:n, consumer:topic  1:1</p>\n</li>\n<li>\n<p>标签（Tag）</p>\n<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一主题下设置不同的标签，标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提 供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>\n</li>\n<li>\n<p>队列</p>\n<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一 个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>\n<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。<strong>一个Queue中的消息不允许同 一个消费者组中的多个消费者同时消费。</strong></p>\n</li>\n<li>\n<p>消息标识</p>\n<p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息到达Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>\n<ul>\n<li>\n<p>msgId：由producer端生成，</p>\n<p>其生成规则为： producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p>\n</li>\n<li>\n<p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的 偏移量）</p>\n</li>\n<li>\n<p>key：由用户指定的业务相关的唯一标识</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"rocketmq四部分\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq四部分\"><span>RocketMQ四部分</span></a></h4>\n<ol>\n<li>\n<p>Producer</p>\n<p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投 递，投递的过程支持快速失败并且低延迟。</p>\n<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>\n</li>\n<li>\n<p>Consumer</p>\n<p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务 处理。</p>\n<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消 费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现 负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注 意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可 以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>\n</li>\n<li>\n<p>Name Server</p>\n<p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>\n<p>主要包括两个功能：</p>\n<ul>\n<li><strong>Broker管理</strong>：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测 机制，检查Broker是否还存活。</li>\n<li><strong>路由信息管理</strong>：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列 信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消 息的投递和消费。</li>\n</ul>\n<p>路由注册：</p>\n<p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各 个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在 Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在 NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。</p>\n</li>\n<li>\n<p>Broker</p>\n<p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从 生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括 消费者组消费进度偏移offset、主题、队列等。</p>\n</li>\n</ol>\n</template>","contentStripped":"<h4 id=\"rocketmq概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq概述\"><span>RocketMQ概述</span></a></h4>\n<p>官网：https://rocketmq.apache.org/zh/docs/domainModel/01main</p>\n<p>RocketMQ中消息的生命周期分为三部分：消息生产，消息存储，消息消费。</p>\n<p>生产者生产消息并发送至RocketMQ服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。</p>\n<h5 id=\"消息生产者-producer\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息生产者-producer\"><span>消息生产者（Producer）</span></a></h5>\n<p>用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级、匿名、无身份的。</p>\n<h5 id=\"消息存储\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息存储\"><span>消息存储</span></a></h5>\n<ul>\n<li>\n<p>主题（Topic）</p>\n<p>消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。</p>\n</li>\n<li>\n<p>队列（MessageQueue）</p>\n<p>消息传输和存储的实际单元容器，类比于其它消息队列中的分区。RocketMQ通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特性。</p>\n</li>\n<li>\n<p>消息（Message）</p>\n<p>最小的传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变</p>\n</li>\n</ul>\n<h5 id=\"消息消费\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#消息消费\"><span>消息消费</span></a></h5>\n<ul>\n<li>\n<p>消费分组（ConsumerGroup）</p>\n<p>RocketMQ发布订阅模型中定义的独立的消费身份，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持<strong>消费逻辑和配置一致</strong>，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p>\n</li>\n<li>\n<p>消费者（Consumer）</p>\n<p>消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</p>\n</li>\n<li>\n<p>订阅关系（Subscription）</p>\n<p>发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p>\n<p>RocketMQ的订阅关系除过滤表达式之外都是持久化的，即服务器重启或请求断开，订阅关系依然保留。</p>\n</li>\n</ul>\n<h4 id=\"rocketmq基本概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq基本概念\"><span>RocketMQ基本概念</span></a></h4>\n<ol>\n<li>\n<p>消息（Message）</p>\n<p>消息是消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>\n</li>\n<li>\n<p>主题（Topic）</p>\n<p>Topic表示一类消息的集合，每个主题必须包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消费订阅的基本单位。topic:message  1:n,  message:topic: 1:1</p>\n<p>一个生产者可以同时发送多种topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种topic的消息。producer:topic   1:n, consumer:topic  1:1</p>\n</li>\n<li>\n<p>标签（Tag）</p>\n<p>为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一主题下设置不同的标签，标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提 供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>\n<p>Topic是消息的一级分类，Tag是消息的二级分类。</p>\n</li>\n<li>\n<p>队列</p>\n<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一 个Topic的Queue也被称为一个Topic中消息的分区（Partition）。</p>\n<p>一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。<strong>一个Queue中的消息不允许同 一个消费者组中的多个消费者同时消费。</strong></p>\n</li>\n<li>\n<p>消息标识</p>\n<p>RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息到达Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>\n<ul>\n<li>\n<p>msgId：由producer端生成，</p>\n<p>其生成规则为： producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p>\n</li>\n<li>\n<p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的 偏移量）</p>\n</li>\n<li>\n<p>key：由用户指定的业务相关的唯一标识</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"rocketmq四部分\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#rocketmq四部分\"><span>RocketMQ四部分</span></a></h4>\n<ol>\n<li>\n<p>Producer</p>\n<p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投 递，投递的过程支持快速失败并且低延迟。</p>\n<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>\n</li>\n<li>\n<p>Consumer</p>\n<p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务 处理。</p>\n<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消 费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现 负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注 意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可 以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>\n</li>\n<li>\n<p>Name Server</p>\n<p>NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。</p>\n<p>主要包括两个功能：</p>\n<ul>\n<li><strong>Broker管理</strong>：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测 机制，检查Broker是否还存活。</li>\n<li><strong>路由信息管理</strong>：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列 信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消 息的投递和消费。</li>\n</ul>\n<p>路由注册：</p>\n<p>NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各 个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在 Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在 NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。</p>\n</li>\n<li>\n<p>Broker</p>\n<p>Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从 生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括 消费者组消费进度偏移offset、主题、队列等。</p>\n</li>\n</ol>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"#### RocketMQ概述\r\n\r\n官网：https://rocketmq.apache.org/zh/docs/domainModel/01main\r\n\r\nRocketMQ中消息的生命周期分为三部分：消息生产，消息存储，消息消费。\r\n\r\n生产者生产消息并发送至RocketMQ服务端，消息被存储在服务端的主题中，消费者通过订阅主题消费消息。\r\n\r\n##### 消息生产者（Producer）\r\n\r\n用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级、匿名、无身份的。\r\n\r\n##### 消息存储\r\n\r\n+ 主题（Topic）\r\n\r\n  消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。\r\n\r\n+ 队列（MessageQueue）\r\n\r\n  消息传输和存储的实际单元容器，类比于其它消息队列中的分区。RocketMQ通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特性。\r\n\r\n+ 消息（Message）\r\n\r\n  最小的传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变\r\n\r\n##### 消息消费\r\n\r\n+ 消费分组（ConsumerGroup）\r\n\r\n  RocketMQ发布订阅模型中定义的独立的消费身份，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持**消费逻辑和配置一致**，共同分担该消费组订阅的消息，实现消费能力的水平扩展。\r\n\r\n+ 消费者（Consumer）\r\n\r\n  消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。\r\n\r\n+ 订阅关系（Subscription）\r\n\r\n  发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。\r\n\r\n  RocketMQ的订阅关系除过滤表达式之外都是持久化的，即服务器重启或请求断开，订阅关系依然保留。\r\n\r\n#### RocketMQ基本概念\r\n\r\n1. 消息（Message）\r\n\r\n    消息是消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。\r\n\r\n2. 主题（Topic）\r\n\r\n    Topic表示一类消息的集合，每个主题必须包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消费订阅的基本单位。topic:message  1:n,  message:topic: 1:1\r\n\r\n    一个生产者可以同时发送多种topic的消息；而一个消费者只对某种特定的Topic感兴趣，即只可以订阅和消费一种topic的消息。producer:topic   1:n, consumer:topic  1:1  \r\n\r\n3. 标签（Tag）\r\n\r\n    为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的，在同一主题下设置不同的标签，标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提 供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。\r\n\r\n    Topic是消息的一级分类，Tag是消息的二级分类。\r\n\r\n4. 队列\r\n\r\n    存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一 个Topic的Queue也被称为一个Topic中消息的分区（Partition）。\r\n\r\n    一个Topic的Queue中的消息只能被一个消费者组中的一个消费者消费。**一个Queue中的消息不允许同 一个消费者组中的多个消费者同时消费。**\r\n\r\n5. 消息标识\r\n\r\n    RocketMQ中每个消息拥有唯一的MessageId，且可以携带具有业务标识的key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息到达Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。\r\n\r\n    + msgId：由producer端生成，\r\n\r\n        其生成规则为： producerIp + 进程pid + MessageClientIDSetter类的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器\r\n\r\n    + offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（Queue中的 偏移量）\r\n\r\n    + key：由用户指定的业务相关的唯一标识\r\n\r\n#### RocketMQ四部分\r\n\r\n1. Producer\r\n\r\n    消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投 递，投递的过程支持快速失败并且低延迟。\r\n\r\n    RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。\r\n\r\n2. Consumer\r\n\r\n    消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务 处理。\r\n\r\n    RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消 费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现 负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注 意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可 以接着消费原Consumer消费的Queue）的目标变得非常容易。\r\n\r\n3. Name Server\r\n\r\n    NameServer是一个Broker与Topic路由的注册中心，支持Broker的动态注册与发现。\r\n\r\n    主要包括两个功能：\r\n\r\n    + **Broker管理**：接受Broker集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测 机制，检查Broker是否还存活。\r\n    + **路由信息管理**：每个NameServer中都保存着Broker集群的整个路由信息和用于客户端查询的队列 信息。Producer和Conumser通过NameServer可以获取整个Broker集群的路由信息，从而进行消 息的投递和消费。\r\n\r\n    路由注册：\r\n\r\n    NameServer通常也是以集群的方式部署，不过，NameServer是无状态的，即NameServer集群中的各 个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在 Broker节点启动时，轮询NameServer列表，与每个NameServer节点建立长连接，发起注册请求。在 NameServer内部维护着⼀个Broker列表，用来动态存储Broker的信息。\r\n\r\n    \r\n\r\n4. Broker\r\n\r\n    Broker充当着消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从 生产者发送来的消息，同时为消费者的拉取请求作准备。Broker同时也存储着消息相关的元数据，包括 消费者组消费进度偏移offset、主题、队列等。","excerpt":"","includedFiles":[],"tasklists":0,"title":"","headers":[]}}
