{"content":"<h2 id=\"单一职责原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#单一职责原则\"><span>单一职责原则</span></a></h2>\n<ol>\n<li>降低类的复杂度，一个类只负责一项职责。</li>\n<li>提高类的可读性，可维护性。</li>\n<li>降低变更引起的风险。</li>\n<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。</li>\n</ol>\n<h2 id=\"接口隔离原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#接口隔离原则\"><span>接口隔离原则</span></a></h2>\n<ol>\n<li>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>\n<li>尽可能避免不需要的方法的出现</li>\n</ol>\n<h2 id=\"依赖倒转-倒置-原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#依赖倒转-倒置-原则\"><span>依赖倒转（倒置）原则</span></a></h2>\n<ol>\n<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>\n<li>抽象不应该依赖其细节，细节应该依赖抽象。</li>\n<li>依赖倒置的中心思想是面向接口编程。</li>\n<li>设计理念是：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。</li>\n<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li>\n</ol>\n<h2 id=\"里氏替换原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#里氏替换原则\"><span>里氏替换原则</span></a></h2>\n<ol>\n<li>在使用继承时，在子类中尽量不要重写父类方法</li>\n<li>继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题</li>\n</ol>\n<h2 id=\"开闭原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#开闭原则\"><span>开闭原则</span></a></h2>\n<ol>\n<li>开闭原则时编程中最基础，最重要的设计原则。</li>\n<li>一个软件实体，如类，模块和函数应该对扩展开放（提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。</li>\n<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改自己的代码来实现变化。</li>\n<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>\n</ol>\n<h2 id=\"迪米特法则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#迪米特法则\"><span>迪米特法则</span></a></h2>\n<ol>\n<li>一个对象应该对其它对象保持最少的了解。</li>\n<li>类与类关系越密切，耦合度越大。</li>\n<li>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li>\n<li>只与直接的朋友（出现成员变量，方法参数，方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）通信</li>\n</ol>\n<h2 id=\"合成复用原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#合成复用原则\"><span>合成复用原则</span></a></h2>\n<ol>\n<li>原则是尽量使用 <strong>合成/聚合</strong> 的方式，而不是使用 <strong>继承</strong> 。</li>\n</ol>\n<h2 id=\"设计原则的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计原则的核心思想\"><span>设计原则的核心思想</span></a></h2>\n<ol>\n<li>找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>为了交互对象之间的松耦合设计而努力。</li>\n</ol>\n","env":{"base":"/","filePath":"C:/Users/kylinBachelor/Desktop/kylinBachelor.github.io/docs/notes/设计模式/设计原则/index.md","filePathRelative":"notes/设计模式/设计原则/index.md","frontmatter":{"title":"设计原则","aliases":null,"tags":["设计模式"],"description":"设计原则","createTime":"2024/11/30 14:15:41","draft":false},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"单一职责原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#单一职责原则\"><span>单一职责原则</span></a></h2>\n<ol>\n<li>降低类的复杂度，一个类只负责一项职责。</li>\n<li>提高类的可读性，可维护性。</li>\n<li>降低变更引起的风险。</li>\n<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。</li>\n</ol>\n<h2 id=\"接口隔离原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#接口隔离原则\"><span>接口隔离原则</span></a></h2>\n<ol>\n<li>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>\n<li>尽可能避免不需要的方法的出现</li>\n</ol>\n<h2 id=\"依赖倒转-倒置-原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#依赖倒转-倒置-原则\"><span>依赖倒转（倒置）原则</span></a></h2>\n<ol>\n<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>\n<li>抽象不应该依赖其细节，细节应该依赖抽象。</li>\n<li>依赖倒置的中心思想是面向接口编程。</li>\n<li>设计理念是：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。</li>\n<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li>\n</ol>\n<h2 id=\"里氏替换原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#里氏替换原则\"><span>里氏替换原则</span></a></h2>\n<ol>\n<li>在使用继承时，在子类中尽量不要重写父类方法</li>\n<li>继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题</li>\n</ol>\n<h2 id=\"开闭原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#开闭原则\"><span>开闭原则</span></a></h2>\n<ol>\n<li>开闭原则时编程中最基础，最重要的设计原则。</li>\n<li>一个软件实体，如类，模块和函数应该对扩展开放（提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。</li>\n<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改自己的代码来实现变化。</li>\n<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>\n</ol>\n<h2 id=\"迪米特法则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#迪米特法则\"><span>迪米特法则</span></a></h2>\n<ol>\n<li>一个对象应该对其它对象保持最少的了解。</li>\n<li>类与类关系越密切，耦合度越大。</li>\n<li>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li>\n<li>只与直接的朋友（出现成员变量，方法参数，方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）通信</li>\n</ol>\n<h2 id=\"合成复用原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#合成复用原则\"><span>合成复用原则</span></a></h2>\n<ol>\n<li>原则是尽量使用 <strong>合成/聚合</strong> 的方式，而不是使用 <strong>继承</strong> 。</li>\n</ol>\n<h2 id=\"设计原则的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计原则的核心思想\"><span>设计原则的核心思想</span></a></h2>\n<ol>\n<li>找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>为了交互对象之间的松耦合设计而努力。</li>\n</ol>\n</template>","contentStripped":"<h2 id=\"单一职责原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#单一职责原则\"><span>单一职责原则</span></a></h2>\n<ol>\n<li>降低类的复杂度，一个类只负责一项职责。</li>\n<li>提高类的可读性，可维护性。</li>\n<li>降低变更引起的风险。</li>\n<li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。</li>\n</ol>\n<h2 id=\"接口隔离原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#接口隔离原则\"><span>接口隔离原则</span></a></h2>\n<ol>\n<li>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li>\n<li>尽可能避免不需要的方法的出现</li>\n</ol>\n<h2 id=\"依赖倒转-倒置-原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#依赖倒转-倒置-原则\"><span>依赖倒转（倒置）原则</span></a></h2>\n<ol>\n<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>\n<li>抽象不应该依赖其细节，细节应该依赖抽象。</li>\n<li>依赖倒置的中心思想是面向接口编程。</li>\n<li>设计理念是：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。</li>\n<li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li>\n</ol>\n<h2 id=\"里氏替换原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#里氏替换原则\"><span>里氏替换原则</span></a></h2>\n<ol>\n<li>在使用继承时，在子类中尽量不要重写父类方法</li>\n<li>继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题</li>\n</ol>\n<h2 id=\"开闭原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#开闭原则\"><span>开闭原则</span></a></h2>\n<ol>\n<li>开闭原则时编程中最基础，最重要的设计原则。</li>\n<li>一个软件实体，如类，模块和函数应该对扩展开放（提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。</li>\n<li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改自己的代码来实现变化。</li>\n<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>\n</ol>\n<h2 id=\"迪米特法则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#迪米特法则\"><span>迪米特法则</span></a></h2>\n<ol>\n<li>一个对象应该对其它对象保持最少的了解。</li>\n<li>类与类关系越密切，耦合度越大。</li>\n<li>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li>\n<li>只与直接的朋友（出现成员变量，方法参数，方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）通信</li>\n</ol>\n<h2 id=\"合成复用原则\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#合成复用原则\"><span>合成复用原则</span></a></h2>\n<ol>\n<li>原则是尽量使用 <strong>合成/聚合</strong> 的方式，而不是使用 <strong>继承</strong> 。</li>\n</ol>\n<h2 id=\"设计原则的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计原则的核心思想\"><span>设计原则的核心思想</span></a></h2>\n<ol>\n<li>找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li>\n<li>针对接口编程，而不是针对实现编程。</li>\n<li>为了交互对象之间的松耦合设计而努力。</li>\n</ol>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## 单一职责原则\r\n\r\n1.  降低类的复杂度，一个类只负责一项职责。\r\n2.  提高类的可读性，可维护性。\r\n3.  降低变更引起的风险。\r\n4.  通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。\r\n\r\n\r\n## 接口隔离原则\r\n\r\n1.  客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上\r\n2.  尽可能避免不需要的方法的出现\r\n\r\n\r\n## 依赖倒转（倒置）原则\r\n\r\n1.  高层模块不应该依赖低层模块，二者都应该依赖其抽象\r\n2.  抽象不应该依赖其细节，细节应该依赖抽象。\r\n3.  依赖倒置的中心思想是面向接口编程。\r\n4.  设计理念是：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。\r\n5.  使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。\r\n\r\n\r\n## 里氏替换原则\r\n\r\n1.  在使用继承时，在子类中尽量不要重写父类方法\r\n2.  继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题\r\n\r\n\r\n## 开闭原则\r\n\r\n1.  开闭原则时编程中最基础，最重要的设计原则。\r\n2.  一个软件实体，如类，模块和函数应该对扩展开放（提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。\r\n3.  当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改自己的代码来实现变化。\r\n4.  编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。\r\n\r\n\r\n## 迪米特法则\r\n\r\n1.  一个对象应该对其它对象保持最少的了解。\r\n2.  类与类关系越密切，耦合度越大。\r\n3.  一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息\r\n4.  只与直接的朋友（出现成员变量，方法参数，方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）通信\r\n\r\n\r\n## 合成复用原则\r\n\r\n1.  原则是尽量使用 **合成/聚合** 的方式，而不是使用 **继承** 。\r\n\r\n\r\n## 设计原则的核心思想\r\n\r\n1.  找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。\r\n2.  针对接口编程，而不是针对实现编程。\r\n3.  为了交互对象之间的松耦合设计而努力。","excerpt":"","includedFiles":[],"tasklists":0,"title":"","headers":[{"level":2,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":2,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[]},{"level":2,"title":"依赖倒转（倒置）原则","slug":"依赖倒转-倒置-原则","link":"#依赖倒转-倒置-原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"开闭原则","slug":"开闭原则","link":"#开闭原则","children":[]},{"level":2,"title":"迪米特法则","slug":"迪米特法则","link":"#迪米特法则","children":[]},{"level":2,"title":"合成复用原则","slug":"合成复用原则","link":"#合成复用原则","children":[]},{"level":2,"title":"设计原则的核心思想","slug":"设计原则的核心思想","link":"#设计原则的核心思想","children":[]}]}}
