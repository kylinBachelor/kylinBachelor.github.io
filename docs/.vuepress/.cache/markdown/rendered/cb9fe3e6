{"content":"<h1 id=\"_1-k8s基本介绍\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-k8s基本介绍\"><span>1. k8s基本介绍</span></a></h1>\n<h2 id=\"_1-概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-概述\"><span>1. 概述</span></a></h2>\n<ol>\n<li>k8s是谷歌在2014年开源的容器化集群管理系统</li>\n<li>使用k8s进行容器化应用部署</li>\n<li>使用k8s有利于应用扩展</li>\n<li>使用k8s最终目的就是为了让部署容器化应用的过程更加简洁和高效</li>\n</ol>\n<p>##　 2. K8S功能特性</p>\n<p>它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡</p>\n<p>在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问,而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p>\n<h3 id=\"_2-1-自动装箱\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-自动装箱\"><span>2.1 自动装箱</span></a></h3>\n<p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p>\n<h3 id=\"_2-2-自我修复-自愈能力\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-自我修复-自愈能力\"><span>2.2 自我修复(自愈能力)</span></a></h3>\n<p>当容器失败时，会对容器进行重启</p>\n<p>当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度</p>\n<p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p>\n<h3 id=\"_2-3-水平扩展\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-3-水平扩展\"><span>2.3 水平扩展</span></a></h3>\n<p>通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p>\n<h3 id=\"_2-4-服务发现-负载均衡\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-4-服务发现-负载均衡\"><span>2.4 服务发现 | 负载均衡</span></a></h3>\n<p>用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</p>\n<h3 id=\"_2-5-滚动更新\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-5-滚动更新\"><span>2.5 滚动更新</span></a></h3>\n<p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p>\n<h3 id=\"_2-6-版本回退\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-6-版本回退\"><span>2.6 版本回退</span></a></h3>\n<p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p>\n<h3 id=\"_2-7-密钥和配置管理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-7-密钥和配置管理\"><span>2.7 密钥和配置管理</span></a></h3>\n<p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p>\n<h3 id=\"_2-8-存储编排\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-8-存储编排\"><span>2.8 存储编排</span></a></h3>\n<p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p>\n<p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p>\n<h3 id=\"_2-9-批处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-9-批处理\"><span>2.9 批处理</span></a></h3>\n<p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p>\n","env":{"base":"/","filePath":"C:/Users/kylinBachelor/Desktop/my-project/docs/notes/K8S/1.简介/index.md","filePathRelative":"notes/K8S/1.简介/index.md","frontmatter":{},"sfcBlocks":{"template":{"type":"template","content":"<template><h1 id=\"_1-k8s基本介绍\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-k8s基本介绍\"><span>1. k8s基本介绍</span></a></h1>\n<h2 id=\"_1-概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-概述\"><span>1. 概述</span></a></h2>\n<ol>\n<li>k8s是谷歌在2014年开源的容器化集群管理系统</li>\n<li>使用k8s进行容器化应用部署</li>\n<li>使用k8s有利于应用扩展</li>\n<li>使用k8s最终目的就是为了让部署容器化应用的过程更加简洁和高效</li>\n</ol>\n<p>##　 2. K8S功能特性</p>\n<p>它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡</p>\n<p>在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问,而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p>\n<h3 id=\"_2-1-自动装箱\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-自动装箱\"><span>2.1 自动装箱</span></a></h3>\n<p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p>\n<h3 id=\"_2-2-自我修复-自愈能力\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-自我修复-自愈能力\"><span>2.2 自我修复(自愈能力)</span></a></h3>\n<p>当容器失败时，会对容器进行重启</p>\n<p>当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度</p>\n<p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p>\n<h3 id=\"_2-3-水平扩展\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-3-水平扩展\"><span>2.3 水平扩展</span></a></h3>\n<p>通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p>\n<h3 id=\"_2-4-服务发现-负载均衡\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-4-服务发现-负载均衡\"><span>2.4 服务发现 | 负载均衡</span></a></h3>\n<p>用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</p>\n<h3 id=\"_2-5-滚动更新\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-5-滚动更新\"><span>2.5 滚动更新</span></a></h3>\n<p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p>\n<h3 id=\"_2-6-版本回退\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-6-版本回退\"><span>2.6 版本回退</span></a></h3>\n<p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p>\n<h3 id=\"_2-7-密钥和配置管理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-7-密钥和配置管理\"><span>2.7 密钥和配置管理</span></a></h3>\n<p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p>\n<h3 id=\"_2-8-存储编排\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-8-存储编排\"><span>2.8 存储编排</span></a></h3>\n<p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p>\n<p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p>\n<h3 id=\"_2-9-批处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-9-批处理\"><span>2.9 批处理</span></a></h3>\n<p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p>\n</template>","contentStripped":"<h1 id=\"_1-k8s基本介绍\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-k8s基本介绍\"><span>1. k8s基本介绍</span></a></h1>\n<h2 id=\"_1-概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-概述\"><span>1. 概述</span></a></h2>\n<ol>\n<li>k8s是谷歌在2014年开源的容器化集群管理系统</li>\n<li>使用k8s进行容器化应用部署</li>\n<li>使用k8s有利于应用扩展</li>\n<li>使用k8s最终目的就是为了让部署容器化应用的过程更加简洁和高效</li>\n</ol>\n<p>##　 2. K8S功能特性</p>\n<p>它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡</p>\n<p>在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问,而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p>\n<h3 id=\"_2-1-自动装箱\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-自动装箱\"><span>2.1 自动装箱</span></a></h3>\n<p>基于容器对应用运行环境的资源配置要求自动部署应用容器</p>\n<h3 id=\"_2-2-自我修复-自愈能力\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-自我修复-自愈能力\"><span>2.2 自我修复(自愈能力)</span></a></h3>\n<p>当容器失败时，会对容器进行重启</p>\n<p>当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度</p>\n<p>当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务</p>\n<h3 id=\"_2-3-水平扩展\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-3-水平扩展\"><span>2.3 水平扩展</span></a></h3>\n<p>通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁</p>\n<h3 id=\"_2-4-服务发现-负载均衡\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-4-服务发现-负载均衡\"><span>2.4 服务发现 | 负载均衡</span></a></h3>\n<p>用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡</p>\n<h3 id=\"_2-5-滚动更新\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-5-滚动更新\"><span>2.5 滚动更新</span></a></h3>\n<p>可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新</p>\n<h3 id=\"_2-6-版本回退\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-6-版本回退\"><span>2.6 版本回退</span></a></h3>\n<p>可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退</p>\n<h3 id=\"_2-7-密钥和配置管理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-7-密钥和配置管理\"><span>2.7 密钥和配置管理</span></a></h3>\n<p>在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。</p>\n<h3 id=\"_2-8-存储编排\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-8-存储编排\"><span>2.8 存储编排</span></a></h3>\n<p>自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要</p>\n<p>存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务</p>\n<h3 id=\"_2-9-批处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-9-批处理\"><span>2.9 批处理</span></a></h3>\n<p>提供一次性任务，定时任务；满足批量数据处理和分析的场景</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n# 1. k8s基本介绍\r\n\r\n##  1. 概述\r\n\r\n1. k8s是谷歌在2014年开源的容器化集群管理系统\r\n2. 使用k8s进行容器化应用部署\r\n3. 使用k8s有利于应用扩展\r\n4. 使用k8s最终目的就是为了让部署容器化应用的过程更加简洁和高效\r\n\r\n##　 2. K8S功能特性\r\n\r\n它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡\r\n\r\n在 Kubernetes 中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问,而这些细节都不需要运维人员去进行复杂的手工配置和处理。\r\n\r\n### 2.1 自动装箱\r\n\r\n基于容器对应用运行环境的资源配置要求自动部署应用容器\r\n\r\n### 2.2 自我修复(自愈能力)\r\n\r\n当容器失败时，会对容器进行重启\r\n\r\n当所部署的 Node 节点有问题时，会对容器进行重新部署和重新调度\r\n\r\n当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务\r\n\r\n### 2.3 水平扩展\r\n\r\n通过简单的命令、用户 UI 界面或基于 CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁\r\n\r\n###  2.4 服务发现 | 负载均衡\r\n\r\n用户不需使用额外的服务发现机制，就能够基于 Kubernetes 自身能力实现服务发现和负载均衡\r\n\r\n###  2.5 滚动更新\r\n\r\n可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新\r\n\r\n### 2.6 版本回退\r\n\r\n可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退\r\n\r\n### 2.7 密钥和配置管理\r\n\r\n在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。\r\n\r\n### 2.8 存储编排\r\n\r\n自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要\r\n\r\n存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务\r\n\r\n### 2.9 批处理\r\n\r\n提供一次性任务，定时任务；满足批量数据处理和分析的场景","excerpt":"","includedFiles":[],"tasklists":0,"title":"1. k8s基本介绍","headers":[{"level":2,"title":"1. 概述","slug":"_1-概述","link":"#_1-概述","children":[{"level":3,"title":"2.1 自动装箱","slug":"_2-1-自动装箱","link":"#_2-1-自动装箱","children":[]},{"level":3,"title":"2.2 自我修复(自愈能力)","slug":"_2-2-自我修复-自愈能力","link":"#_2-2-自我修复-自愈能力","children":[]},{"level":3,"title":"2.3 水平扩展","slug":"_2-3-水平扩展","link":"#_2-3-水平扩展","children":[]},{"level":3,"title":"2.4 服务发现 | 负载均衡","slug":"_2-4-服务发现-负载均衡","link":"#_2-4-服务发现-负载均衡","children":[]},{"level":3,"title":"2.5 滚动更新","slug":"_2-5-滚动更新","link":"#_2-5-滚动更新","children":[]},{"level":3,"title":"2.6 版本回退","slug":"_2-6-版本回退","link":"#_2-6-版本回退","children":[]},{"level":3,"title":"2.7 密钥和配置管理","slug":"_2-7-密钥和配置管理","link":"#_2-7-密钥和配置管理","children":[]},{"level":3,"title":"2.8 存储编排","slug":"_2-8-存储编排","link":"#_2-8-存储编排","children":[]},{"level":3,"title":"2.9 批处理","slug":"_2-9-批处理","link":"#_2-9-批处理","children":[]}]}]}}
