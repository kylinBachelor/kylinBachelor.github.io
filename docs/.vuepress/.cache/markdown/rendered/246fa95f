{"content":"<h1 id=\"docker-网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#docker-网络\"><span>Docker 网络</span></a></h1>\n<p>网络模式：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n<th>指定方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bridge</td>\n<td>为每个容器分配、设置IP等，并将容器连接到一个叫做docker0的虚拟网桥，默认为该模式</td>\n<td>--network bridge</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</td>\n<td>--network host</td>\n</tr>\n<tr>\n<td>none</td>\n<td>容器有独立的Network namespace,但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等</td>\n<td>--network none</td>\n</tr>\n<tr>\n<td>container</td>\n<td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP,端口范围</td>\n<td>--network container:name或者容器id</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<ol>\n<li>查看网络模式：docker netword ls</li>\n<li>查看网络模式详情： docker inspect network bridge/host/自定义网络模式</li>\n<li>查看容器网络：docker inspect 容器name或容器id</li>\n</ol>\n</div>\n<h2 id=\"_1-bridge\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-bridge\"><span>1. bridge</span></a></h2>\n<p><strong>Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称就是docker0,它在内核层联通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放在了同一个物理网络。Docker默认指定了docker0接口的ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</strong></p>\n<h3 id=\"_1-1-虚拟网桥\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-1-虚拟网桥\"><span>1.1 虚拟网桥</span></a></h3>\n<p>当启动docker时会产生一个名字为docker0的虚拟网桥</p>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710102649394.png\" alt=\"image-20240710102649394\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710102649394</figcaption></figure>\n<p>docker就是通过docker0这个虚拟网桥和宿主机之间以及容器和容器之间进行网络通信的。</p>\n<p><strong>测试镜像： docker run -d -p 8083:8080 --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<h3 id=\"_1-2-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-2-模型\"><span>1.2. 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710111406345.png\" alt=\"image-20240710111406345\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710111406345</figcaption></figure>\n<ol>\n<li>\n<p>整个宿主机的网桥模式都是docker0,类似于一个交换机有一堆接口，每个接口叫veth,在本地主机和容器内分别创建一个虚拟接口，并让他们彼此之间可以联通（这样一对接口叫做veth pair）</p>\n</li>\n<li>\n<p>每个容器实例内部也有一块网卡，每个接口叫做eth0;</p>\n</li>\n<li>\n<p>docker0上面的每个veth匹配某个容器实例内部的eth0,两两配对、一一匹配。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>综述：将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下拿到各自分配的ip,此时两个容器之间的网络是相通的。</p>\n</div>\n</li>\n</ol>\n<h2 id=\"_2-host\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-host\"><span>2. host</span></a></h2>\n<blockquote>\n<p>=== 直接使用宿主机的IP地址与外界进行通信，不再需要额外的进行NAT转换.</p>\n</blockquote>\n<p><strong>测试镜像： docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>docker 启动时如果指定了 -p 映射端口，会出现警告。</p>\n<p>host 模式下 -p  指定的端口将不会起到任何作用，端口号会以主机端口号为主。重复时则递增。</p>\n</div>\n<h3 id=\"_2-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-模型\"><span>2.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710123807058.png\" alt=\"image-20240710123807058\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710123807058</figcaption></figure>\n<p>容器将不会获得一个独立的Network Namespace,而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。</p>\n<h2 id=\"_3-none\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-none\"><span>3. none</span></a></h2>\n<blockquote>\n<p>=== 禁用了网络功能，只有lo标识（就是127.0.0.1标识本地回环）</p>\n</blockquote>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710132559964.png\" alt=\"image-20240710132559964\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710132559964</figcaption></figure>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>在none模式下，并不为Docker容器进行任何的网络配置</p>\n<p>Docker容器没有网卡、IP、路由配置等信息，只有lo</p>\n</div>\n<h2 id=\"_4-container\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-container\"><span>4. container</span></a></h2>\n<blockquote>\n<p>=== 新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定容器共享IP、端口范围等。</p>\n<p>两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的。</p>\n</blockquote>\n<h3 id=\"_4-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-模型\"><span>4.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710133326729.png\" alt=\"image-20240710133326729\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710133326729</figcaption></figure>\n<p><strong>docker run -d --network container:tomcat81 --name tomcat82 billygoo/tomcat8-jdk8</strong></p>\n<p>这里如果两个容器都是tomcat不适合，因为8080端口会产生冲突。</p>\n<h2 id=\"_5-自定义网络模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-自定义网络模式\"><span>5. 自定义网络模式</span></a></h2>\n<blockquote>\n<p>=== 可以保证容器之间通过服务名访问</p>\n<p>！！！！！ 自定义网络本身就维护好了主机名和ip的对应关系，ip和域名都能通</p>\n</blockquote>\n<h3 id=\"_5-1-新建自定义网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-1-新建自定义网络\"><span>5.1 新建自定义网络</span></a></h3>\n<p>docker network create test_network</p>\n<h3 id=\"_5-2-新建容器\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-2-新建容器\"><span>5.2 新建容器</span></a></h3>\n<p>docker run -d -p 8081:8080 --network test_network --name tomcat81 billygoo/tomcat8-jdk8</p>\n<p>docker run -d -p 8082:8080 --network test_network --name tomcat82 billygoo/tomcat8-jdk8</p>\n<h3 id=\"_5-3-通过服务名测试服务通信\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-3-通过服务名测试服务通信\"><span>5.3 通过服务名测试服务通信</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710141351877.png\" alt=\"image-20240710141351877\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710141351877</figcaption></figure>\n<h2 id=\"_6-主要用途\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-主要用途\"><span>6. 主要用途</span></a></h2>\n<ol>\n<li>容器之间的互联和通信以及端口映射</li>\n<li>容器IP变动时可以通过服务名连接网络通信而不受影响</li>\n</ol>\n","env":{"base":"/","filePath":"F:/my_source_code/kylinBachelor.github.io/docs/notes/Docker/network/index.md","filePathRelative":"notes/Docker/network/index.md","frontmatter":{},"sfcBlocks":{"template":{"type":"template","content":"<template><h1 id=\"docker-网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#docker-网络\"><span>Docker 网络</span></a></h1>\n<p>网络模式：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n<th>指定方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bridge</td>\n<td>为每个容器分配、设置IP等，并将容器连接到一个叫做docker0的虚拟网桥，默认为该模式</td>\n<td>--network bridge</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</td>\n<td>--network host</td>\n</tr>\n<tr>\n<td>none</td>\n<td>容器有独立的Network namespace,但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等</td>\n<td>--network none</td>\n</tr>\n<tr>\n<td>container</td>\n<td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP,端口范围</td>\n<td>--network container:name或者容器id</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<ol>\n<li>查看网络模式：docker netword ls</li>\n<li>查看网络模式详情： docker inspect network bridge/host/自定义网络模式</li>\n<li>查看容器网络：docker inspect 容器name或容器id</li>\n</ol>\n</div>\n<h2 id=\"_1-bridge\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-bridge\"><span>1. bridge</span></a></h2>\n<p><strong>Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称就是docker0,它在内核层联通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放在了同一个物理网络。Docker默认指定了docker0接口的ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</strong></p>\n<h3 id=\"_1-1-虚拟网桥\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-1-虚拟网桥\"><span>1.1 虚拟网桥</span></a></h3>\n<p>当启动docker时会产生一个名字为docker0的虚拟网桥</p>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710102649394.png\" alt=\"image-20240710102649394\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710102649394</figcaption></figure>\n<p>docker就是通过docker0这个虚拟网桥和宿主机之间以及容器和容器之间进行网络通信的。</p>\n<p><strong>测试镜像： docker run -d -p 8083:8080 --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<h3 id=\"_1-2-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-2-模型\"><span>1.2. 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710111406345.png\" alt=\"image-20240710111406345\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710111406345</figcaption></figure>\n<ol>\n<li>\n<p>整个宿主机的网桥模式都是docker0,类似于一个交换机有一堆接口，每个接口叫veth,在本地主机和容器内分别创建一个虚拟接口，并让他们彼此之间可以联通（这样一对接口叫做veth pair）</p>\n</li>\n<li>\n<p>每个容器实例内部也有一块网卡，每个接口叫做eth0;</p>\n</li>\n<li>\n<p>docker0上面的每个veth匹配某个容器实例内部的eth0,两两配对、一一匹配。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>综述：将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下拿到各自分配的ip,此时两个容器之间的网络是相通的。</p>\n</div>\n</li>\n</ol>\n<h2 id=\"_2-host\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-host\"><span>2. host</span></a></h2>\n<blockquote>\n<p>=== 直接使用宿主机的IP地址与外界进行通信，不再需要额外的进行NAT转换.</p>\n</blockquote>\n<p><strong>测试镜像： docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>docker 启动时如果指定了 -p 映射端口，会出现警告。</p>\n<p>host 模式下 -p  指定的端口将不会起到任何作用，端口号会以主机端口号为主。重复时则递增。</p>\n</div>\n<h3 id=\"_2-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-模型\"><span>2.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710123807058.png\" alt=\"image-20240710123807058\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710123807058</figcaption></figure>\n<p>容器将不会获得一个独立的Network Namespace,而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。</p>\n<h2 id=\"_3-none\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-none\"><span>3. none</span></a></h2>\n<blockquote>\n<p>=== 禁用了网络功能，只有lo标识（就是127.0.0.1标识本地回环）</p>\n</blockquote>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710132559964.png\" alt=\"image-20240710132559964\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710132559964</figcaption></figure>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>在none模式下，并不为Docker容器进行任何的网络配置</p>\n<p>Docker容器没有网卡、IP、路由配置等信息，只有lo</p>\n</div>\n<h2 id=\"_4-container\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-container\"><span>4. container</span></a></h2>\n<blockquote>\n<p>=== 新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定容器共享IP、端口范围等。</p>\n<p>两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的。</p>\n</blockquote>\n<h3 id=\"_4-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-模型\"><span>4.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710133326729.png\" alt=\"image-20240710133326729\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710133326729</figcaption></figure>\n<p><strong>docker run -d --network container:tomcat81 --name tomcat82 billygoo/tomcat8-jdk8</strong></p>\n<p>这里如果两个容器都是tomcat不适合，因为8080端口会产生冲突。</p>\n<h2 id=\"_5-自定义网络模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-自定义网络模式\"><span>5. 自定义网络模式</span></a></h2>\n<blockquote>\n<p>=== 可以保证容器之间通过服务名访问</p>\n<p>！！！！！ 自定义网络本身就维护好了主机名和ip的对应关系，ip和域名都能通</p>\n</blockquote>\n<h3 id=\"_5-1-新建自定义网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-1-新建自定义网络\"><span>5.1 新建自定义网络</span></a></h3>\n<p>docker network create test_network</p>\n<h3 id=\"_5-2-新建容器\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-2-新建容器\"><span>5.2 新建容器</span></a></h3>\n<p>docker run -d -p 8081:8080 --network test_network --name tomcat81 billygoo/tomcat8-jdk8</p>\n<p>docker run -d -p 8082:8080 --network test_network --name tomcat82 billygoo/tomcat8-jdk8</p>\n<h3 id=\"_5-3-通过服务名测试服务通信\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-3-通过服务名测试服务通信\"><span>5.3 通过服务名测试服务通信</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710141351877.png\" alt=\"image-20240710141351877\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710141351877</figcaption></figure>\n<h2 id=\"_6-主要用途\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-主要用途\"><span>6. 主要用途</span></a></h2>\n<ol>\n<li>容器之间的互联和通信以及端口映射</li>\n<li>容器IP变动时可以通过服务名连接网络通信而不受影响</li>\n</ol>\n</template>","contentStripped":"<h1 id=\"docker-网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#docker-网络\"><span>Docker 网络</span></a></h1>\n<p>网络模式：</p>\n<table>\n<thead>\n<tr>\n<th>网络模式</th>\n<th>简介</th>\n<th>指定方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bridge</td>\n<td>为每个容器分配、设置IP等，并将容器连接到一个叫做docker0的虚拟网桥，默认为该模式</td>\n<td>--network bridge</td>\n</tr>\n<tr>\n<td>host</td>\n<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</td>\n<td>--network host</td>\n</tr>\n<tr>\n<td>none</td>\n<td>容器有独立的Network namespace,但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等</td>\n<td>--network none</td>\n</tr>\n<tr>\n<td>container</td>\n<td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP,端口范围</td>\n<td>--network container:name或者容器id</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<ol>\n<li>查看网络模式：docker netword ls</li>\n<li>查看网络模式详情： docker inspect network bridge/host/自定义网络模式</li>\n<li>查看容器网络：docker inspect 容器name或容器id</li>\n</ol>\n</div>\n<h2 id=\"_1-bridge\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-bridge\"><span>1. bridge</span></a></h2>\n<p><strong>Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称就是docker0,它在内核层联通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放在了同一个物理网络。Docker默认指定了docker0接口的ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</strong></p>\n<h3 id=\"_1-1-虚拟网桥\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-1-虚拟网桥\"><span>1.1 虚拟网桥</span></a></h3>\n<p>当启动docker时会产生一个名字为docker0的虚拟网桥</p>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710102649394.png\" alt=\"image-20240710102649394\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710102649394</figcaption></figure>\n<p>docker就是通过docker0这个虚拟网桥和宿主机之间以及容器和容器之间进行网络通信的。</p>\n<p><strong>测试镜像： docker run -d -p 8083:8080 --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<h3 id=\"_1-2-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-2-模型\"><span>1.2. 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710111406345.png\" alt=\"image-20240710111406345\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710111406345</figcaption></figure>\n<ol>\n<li>\n<p>整个宿主机的网桥模式都是docker0,类似于一个交换机有一堆接口，每个接口叫veth,在本地主机和容器内分别创建一个虚拟接口，并让他们彼此之间可以联通（这样一对接口叫做veth pair）</p>\n</li>\n<li>\n<p>每个容器实例内部也有一块网卡，每个接口叫做eth0;</p>\n</li>\n<li>\n<p>docker0上面的每个veth匹配某个容器实例内部的eth0,两两配对、一一匹配。</p>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>综述：将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下拿到各自分配的ip,此时两个容器之间的网络是相通的。</p>\n</div>\n</li>\n</ol>\n<h2 id=\"_2-host\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-host\"><span>2. host</span></a></h2>\n<blockquote>\n<p>=== 直接使用宿主机的IP地址与外界进行通信，不再需要额外的进行NAT转换.</p>\n</blockquote>\n<p><strong>测试镜像： docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</strong></p>\n<div class=\"hint-container warning\">\n<p class=\"hint-container-title\">注意</p>\n<p>docker 启动时如果指定了 -p 映射端口，会出现警告。</p>\n<p>host 模式下 -p  指定的端口将不会起到任何作用，端口号会以主机端口号为主。重复时则递增。</p>\n</div>\n<h3 id=\"_2-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-模型\"><span>2.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710123807058.png\" alt=\"image-20240710123807058\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710123807058</figcaption></figure>\n<p>容器将不会获得一个独立的Network Namespace,而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。</p>\n<h2 id=\"_3-none\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-none\"><span>3. none</span></a></h2>\n<blockquote>\n<p>=== 禁用了网络功能，只有lo标识（就是127.0.0.1标识本地回环）</p>\n</blockquote>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710132559964.png\" alt=\"image-20240710132559964\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710132559964</figcaption></figure>\n<div class=\"hint-container note\">\n<p class=\"hint-container-title\">注</p>\n<p>在none模式下，并不为Docker容器进行任何的网络配置</p>\n<p>Docker容器没有网卡、IP、路由配置等信息，只有lo</p>\n</div>\n<h2 id=\"_4-container\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-container\"><span>4. container</span></a></h2>\n<blockquote>\n<p>=== 新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定容器共享IP、端口范围等。</p>\n<p>两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的。</p>\n</blockquote>\n<h3 id=\"_4-1-模型\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-模型\"><span>4.1 模型</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710133326729.png\" alt=\"image-20240710133326729\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710133326729</figcaption></figure>\n<p><strong>docker run -d --network container:tomcat81 --name tomcat82 billygoo/tomcat8-jdk8</strong></p>\n<p>这里如果两个容器都是tomcat不适合，因为8080端口会产生冲突。</p>\n<h2 id=\"_5-自定义网络模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-自定义网络模式\"><span>5. 自定义网络模式</span></a></h2>\n<blockquote>\n<p>=== 可以保证容器之间通过服务名访问</p>\n<p>！！！！！ 自定义网络本身就维护好了主机名和ip的对应关系，ip和域名都能通</p>\n</blockquote>\n<h3 id=\"_5-1-新建自定义网络\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-1-新建自定义网络\"><span>5.1 新建自定义网络</span></a></h3>\n<p>docker network create test_network</p>\n<h3 id=\"_5-2-新建容器\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-2-新建容器\"><span>5.2 新建容器</span></a></h3>\n<p>docker run -d -p 8081:8080 --network test_network --name tomcat81 billygoo/tomcat8-jdk8</p>\n<p>docker run -d -p 8082:8080 --network test_network --name tomcat82 billygoo/tomcat8-jdk8</p>\n<h3 id=\"_5-3-通过服务名测试服务通信\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-3-通过服务名测试服务通信\"><span>5.3 通过服务名测试服务通信</span></a></h3>\n<figure><img src=\"@source/notes/Docker/network/assets/image-20240710141351877.png\" alt=\"image-20240710141351877\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20240710141351877</figcaption></figure>\n<h2 id=\"_6-主要用途\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-主要用途\"><span>6. 主要用途</span></a></h2>\n<ol>\n<li>容器之间的互联和通信以及端口映射</li>\n<li>容器IP变动时可以通过服务名连接网络通信而不受影响</li>\n</ol>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n# Docker 网络\r\n\r\n网络模式：\r\n\r\n| 网络模式  | 简介                                                         | 指定方式                           |\r\n| --------- | ------------------------------------------------------------ | ---------------------------------- |\r\n| bridge    | 为每个容器分配、设置IP等，并将容器连接到一个叫做docker0的虚拟网桥，默认为该模式 | --network bridge                   |\r\n| host      | 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口 | --network host                     |\r\n| none      | 容器有独立的Network namespace,但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等 | --network none                     |\r\n| container | 新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP,端口范围 | --network container:name或者容器id |\r\n\r\n\r\n\r\n> [!note]\r\n>\r\n> 1. 查看网络模式：docker netword ls\r\n> 2. 查看网络模式详情： docker inspect network bridge/host/自定义网络模式\r\n> 3. 查看容器网络：docker inspect 容器name或容器id\r\n\r\n## 1. bridge\r\n\r\n**Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称就是docker0,它在内核层联通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放在了同一个物理网络。Docker默认指定了docker0接口的ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。**\r\n\r\n### 1.1 虚拟网桥\r\n\r\n当启动docker时会产生一个名字为docker0的虚拟网桥\r\n\r\n![image-20240710102649394](./assets/image-20240710102649394.png)\r\n\r\ndocker就是通过docker0这个虚拟网桥和宿主机之间以及容器和容器之间进行网络通信的。\r\n\r\n**测试镜像： docker run -d -p 8083:8080 --name tomcat83 billygoo/tomcat8-jdk8**\r\n\r\n### 1.2. 模型\r\n\r\n\r\n\r\n![image-20240710111406345](./assets/image-20240710111406345.png)\r\n\r\n\r\n\r\n1. 整个宿主机的网桥模式都是docker0,类似于一个交换机有一堆接口，每个接口叫veth,在本地主机和容器内分别创建一个虚拟接口，并让他们彼此之间可以联通（这样一对接口叫做veth pair）\r\n\r\n2. 每个容器实例内部也有一块网卡，每个接口叫做eth0;\r\n\r\n3. docker0上面的每个veth匹配某个容器实例内部的eth0,两两配对、一一匹配。\r\n\r\n    \r\n\r\n    > [!note]\r\n    >\r\n    > 综述：将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下拿到各自分配的ip,此时两个容器之间的网络是相通的。\r\n\r\n## 2. host\r\n\r\n> === 直接使用宿主机的IP地址与外界进行通信，不再需要额外的进行NAT转换.\r\n\r\n**测试镜像： docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8**\r\n\r\n\r\n\r\n> [!warning]\r\n>\r\n> docker 启动时如果指定了 -p 映射端口，会出现警告。\r\n>\r\n> host 模式下 -p  指定的端口将不会起到任何作用，端口号会以主机端口号为主。重复时则递增。\r\n\r\n### 2.1 模型\r\n\r\n![image-20240710123807058](./assets/image-20240710123807058.png)\r\n\r\n容器将不会获得一个独立的Network Namespace,而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。\r\n\r\n\r\n\r\n## 3. none\r\n\r\n> === 禁用了网络功能，只有lo标识（就是127.0.0.1标识本地回环）\r\n\r\n![image-20240710132559964](./assets/image-20240710132559964.png)\r\n\r\n> [!note]\r\n>\r\n> 在none模式下，并不为Docker容器进行任何的网络配置\r\n>\r\n> Docker容器没有网卡、IP、路由配置等信息，只有lo\r\n\r\n## 4. container\t\r\n\r\n> === 新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定容器共享IP、端口范围等。\r\n>\r\n> 两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的。\r\n\r\n### 4.1 模型\r\n\r\n![image-20240710133326729](./assets/image-20240710133326729.png)\r\n\r\n**docker run -d --network container:tomcat81 --name tomcat82 billygoo/tomcat8-jdk8**\r\n\r\n这里如果两个容器都是tomcat不适合，因为8080端口会产生冲突。\r\n\r\n## 5. 自定义网络模式\r\n\r\n> === 可以保证容器之间通过服务名访问\r\n>\r\n> ！！！！！ 自定义网络本身就维护好了主机名和ip的对应关系，ip和域名都能通\r\n\r\n### 5.1 新建自定义网络\r\n\r\ndocker network create test_network\r\n\r\n### 5.2 新建容器\r\n\r\ndocker run -d -p 8081:8080 --network test_network --name tomcat81 billygoo/tomcat8-jdk8\r\n\r\ndocker run -d -p 8082:8080 --network test_network --name tomcat82 billygoo/tomcat8-jdk8\r\n\r\n### 5.3 通过服务名测试服务通信\r\n\r\n![image-20240710141351877](./assets/image-20240710141351877.png)\r\n\r\n\r\n\r\n\r\n\r\n## 6. 主要用途\r\n\r\n1. 容器之间的互联和通信以及端口映射\r\n2. 容器IP变动时可以通过服务名连接网络通信而不受影响","excerpt":"","includedFiles":[],"tasklists":0,"title":"Docker 网络","headers":[{"level":2,"title":"1. bridge","slug":"_1-bridge","link":"#_1-bridge","children":[{"level":3,"title":"1.1 虚拟网桥","slug":"_1-1-虚拟网桥","link":"#_1-1-虚拟网桥","children":[]},{"level":3,"title":"1.2. 模型","slug":"_1-2-模型","link":"#_1-2-模型","children":[]}]},{"level":2,"title":"2. host","slug":"_2-host","link":"#_2-host","children":[{"level":3,"title":"2.1 模型","slug":"_2-1-模型","link":"#_2-1-模型","children":[]}]},{"level":2,"title":"3. none","slug":"_3-none","link":"#_3-none","children":[]},{"level":2,"title":"4. container","slug":"_4-container","link":"#_4-container","children":[{"level":3,"title":"4.1 模型","slug":"_4-1-模型","link":"#_4-1-模型","children":[]}]},{"level":2,"title":"5. 自定义网络模式","slug":"_5-自定义网络模式","link":"#_5-自定义网络模式","children":[{"level":3,"title":"5.1 新建自定义网络","slug":"_5-1-新建自定义网络","link":"#_5-1-新建自定义网络","children":[]},{"level":3,"title":"5.2 新建容器","slug":"_5-2-新建容器","link":"#_5-2-新建容器","children":[]},{"level":3,"title":"5.3 通过服务名测试服务通信","slug":"_5-3-通过服务名测试服务通信","link":"#_5-3-通过服务名测试服务通信","children":[]}]},{"level":2,"title":"6. 主要用途","slug":"_6-主要用途","link":"#_6-主要用途","children":[]}]}}
