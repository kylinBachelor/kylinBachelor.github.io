{"content":"<h1 id=\"redis缓存击穿-穿透-雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#redis缓存击穿-穿透-雪崩\"><span>Redis缓存击穿-穿透-雪崩</span></a></h1>\n<h2 id=\"_1-缓存一般使用思路简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-缓存一般使用思路简介\"><span>1. 缓存一般使用思路简介</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115103837372.png\" alt=\"image-20241115103837372\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115103837372</figcaption></figure>\n<ol>\n<li>客户端请求服务</li>\n<li>服务去redis试着拿取数据。</li>\n<li>redis将数据返回给服务，如果返回的结果有数据则执行上图第七步，如果没有数据则继续向下执行。</li>\n<li>服务从数据库中查询数据。</li>\n<li>数据库将查询结果返回给服务。</li>\n<li>数据库返回数据则添加到redis中。</li>\n<li>请求数据返回给客户端。</li>\n</ol>\n<h2 id=\"_2-缓存穿透\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-缓存穿透\"><span>2. 缓存穿透</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115105231198.png\" alt=\"image-20241115105231198\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115105231198</figcaption></figure>\n<h3 id=\"_2-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-描述\"><span>2.1 描述</span></a></h3>\n<p>通过接口访问一个缓存和数据库都不存在的数据。</p>\n<p>服务出于容错考虑，当请求从持久层查不到数据则不写入缓存，这将导致请求这个不存在的数据每次都要到持久层去查询，失去了缓存的意义。此时，缓存起不到保护后端持久层的意义，就像被穿透了一样。导致数据库存在被打挂的风险。</p>\n<h3 id=\"_2-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-解决方案\"><span>2.2 解决方案</span></a></h3>\n<p>1.接口请求参数的校验。对请求的接口进行鉴权，数据合法性的校验等；比如查询的userId不能是负值或者包含非法字符等。</p>\n<p>2.当数据库返回空值时，将空值缓存到redis，并设置合理的过期时间。</p>\n<p>3.<strong>布隆过滤器</strong>。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</p>\n<h2 id=\"_3-缓存击穿\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-缓存击穿\"><span>3. 缓存击穿</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132125907.png\" alt=\"image-20241115132125907\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132125907</figcaption></figure>\n<h3 id=\"_3-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-1-描述\"><span>3.1 描述</span></a></h3>\n<p>某个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_3-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-2-解决方案\"><span>3.2 解决方案</span></a></h3>\n<p>1.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>2.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n<h2 id=\"_4-缓存雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-缓存雪崩\"><span>4. 缓存雪崩</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132540596.png\" alt=\"image-20241115132540596\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132540596</figcaption></figure>\n<h3 id=\"_4-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-描述\"><span>4.1 描述</span></a></h3>\n<p>大量的热点数据过期时间相同，导致数据在同一时刻集体失效。造成瞬时数据库请求量大、压力骤增，引起雪崩，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_4-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-2-解决方案\"><span>4.2 解决方案</span></a></h3>\n<p>1.<strong>将热点数据的过期时间打散</strong>。给热点数据设置过期时间时加个随机值。</p>\n<p>2.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>3.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n","env":{"base":"/","filePath":"C:/Users/kylinBachelor/Desktop/kylinBachelor.github.io/docs/notes/Redis/Redis缓存击穿-穿透-雪崩/index.md","filePathRelative":"notes/Redis/Redis缓存击穿-穿透-雪崩/index.md","frontmatter":{},"sfcBlocks":{"template":{"type":"template","content":"<template><h1 id=\"redis缓存击穿-穿透-雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#redis缓存击穿-穿透-雪崩\"><span>Redis缓存击穿-穿透-雪崩</span></a></h1>\n<h2 id=\"_1-缓存一般使用思路简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-缓存一般使用思路简介\"><span>1. 缓存一般使用思路简介</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115103837372.png\" alt=\"image-20241115103837372\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115103837372</figcaption></figure>\n<ol>\n<li>客户端请求服务</li>\n<li>服务去redis试着拿取数据。</li>\n<li>redis将数据返回给服务，如果返回的结果有数据则执行上图第七步，如果没有数据则继续向下执行。</li>\n<li>服务从数据库中查询数据。</li>\n<li>数据库将查询结果返回给服务。</li>\n<li>数据库返回数据则添加到redis中。</li>\n<li>请求数据返回给客户端。</li>\n</ol>\n<h2 id=\"_2-缓存穿透\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-缓存穿透\"><span>2. 缓存穿透</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115105231198.png\" alt=\"image-20241115105231198\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115105231198</figcaption></figure>\n<h3 id=\"_2-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-描述\"><span>2.1 描述</span></a></h3>\n<p>通过接口访问一个缓存和数据库都不存在的数据。</p>\n<p>服务出于容错考虑，当请求从持久层查不到数据则不写入缓存，这将导致请求这个不存在的数据每次都要到持久层去查询，失去了缓存的意义。此时，缓存起不到保护后端持久层的意义，就像被穿透了一样。导致数据库存在被打挂的风险。</p>\n<h3 id=\"_2-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-解决方案\"><span>2.2 解决方案</span></a></h3>\n<p>1.接口请求参数的校验。对请求的接口进行鉴权，数据合法性的校验等；比如查询的userId不能是负值或者包含非法字符等。</p>\n<p>2.当数据库返回空值时，将空值缓存到redis，并设置合理的过期时间。</p>\n<p>3.<strong>布隆过滤器</strong>。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</p>\n<h2 id=\"_3-缓存击穿\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-缓存击穿\"><span>3. 缓存击穿</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132125907.png\" alt=\"image-20241115132125907\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132125907</figcaption></figure>\n<h3 id=\"_3-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-1-描述\"><span>3.1 描述</span></a></h3>\n<p>某个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_3-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-2-解决方案\"><span>3.2 解决方案</span></a></h3>\n<p>1.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>2.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n<h2 id=\"_4-缓存雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-缓存雪崩\"><span>4. 缓存雪崩</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132540596.png\" alt=\"image-20241115132540596\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132540596</figcaption></figure>\n<h3 id=\"_4-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-描述\"><span>4.1 描述</span></a></h3>\n<p>大量的热点数据过期时间相同，导致数据在同一时刻集体失效。造成瞬时数据库请求量大、压力骤增，引起雪崩，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_4-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-2-解决方案\"><span>4.2 解决方案</span></a></h3>\n<p>1.<strong>将热点数据的过期时间打散</strong>。给热点数据设置过期时间时加个随机值。</p>\n<p>2.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>3.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n</template>","contentStripped":"<h1 id=\"redis缓存击穿-穿透-雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#redis缓存击穿-穿透-雪崩\"><span>Redis缓存击穿-穿透-雪崩</span></a></h1>\n<h2 id=\"_1-缓存一般使用思路简介\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-缓存一般使用思路简介\"><span>1. 缓存一般使用思路简介</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115103837372.png\" alt=\"image-20241115103837372\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115103837372</figcaption></figure>\n<ol>\n<li>客户端请求服务</li>\n<li>服务去redis试着拿取数据。</li>\n<li>redis将数据返回给服务，如果返回的结果有数据则执行上图第七步，如果没有数据则继续向下执行。</li>\n<li>服务从数据库中查询数据。</li>\n<li>数据库将查询结果返回给服务。</li>\n<li>数据库返回数据则添加到redis中。</li>\n<li>请求数据返回给客户端。</li>\n</ol>\n<h2 id=\"_2-缓存穿透\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-缓存穿透\"><span>2. 缓存穿透</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115105231198.png\" alt=\"image-20241115105231198\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115105231198</figcaption></figure>\n<h3 id=\"_2-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-1-描述\"><span>2.1 描述</span></a></h3>\n<p>通过接口访问一个缓存和数据库都不存在的数据。</p>\n<p>服务出于容错考虑，当请求从持久层查不到数据则不写入缓存，这将导致请求这个不存在的数据每次都要到持久层去查询，失去了缓存的意义。此时，缓存起不到保护后端持久层的意义，就像被穿透了一样。导致数据库存在被打挂的风险。</p>\n<h3 id=\"_2-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-2-解决方案\"><span>2.2 解决方案</span></a></h3>\n<p>1.接口请求参数的校验。对请求的接口进行鉴权，数据合法性的校验等；比如查询的userId不能是负值或者包含非法字符等。</p>\n<p>2.当数据库返回空值时，将空值缓存到redis，并设置合理的过期时间。</p>\n<p>3.<strong>布隆过滤器</strong>。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。</p>\n<h2 id=\"_3-缓存击穿\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-缓存击穿\"><span>3. 缓存击穿</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132125907.png\" alt=\"image-20241115132125907\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132125907</figcaption></figure>\n<h3 id=\"_3-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-1-描述\"><span>3.1 描述</span></a></h3>\n<p>某个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_3-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-2-解决方案\"><span>3.2 解决方案</span></a></h3>\n<p>1.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>2.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n<h2 id=\"_4-缓存雪崩\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-缓存雪崩\"><span>4. 缓存雪崩</span></a></h2>\n<figure><img src=\"@source/notes/Redis/Redis缓存击穿-穿透-雪崩/assets/image-20241115132540596.png\" alt=\"image-20241115132540596\" tabindex=\"0\" loading=\"lazy\"><figcaption>image-20241115132540596</figcaption></figure>\n<h3 id=\"_4-1-描述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-1-描述\"><span>4.1 描述</span></a></h3>\n<p>大量的热点数据过期时间相同，导致数据在同一时刻集体失效。造成瞬时数据库请求量大、压力骤增，引起雪崩，导致数据库存在被打挂的风险。</p>\n<h3 id=\"_4-2-解决方案\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-2-解决方案\"><span>4.2 解决方案</span></a></h3>\n<p>1.<strong>将热点数据的过期时间打散</strong>。给热点数据设置过期时间时加个随机值。</p>\n<p>2.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。</p>\n<p>3.设置缓存不过期或者后台有线程一直给热点数据续期。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n# Redis缓存击穿-穿透-雪崩\r\n\r\n## 1. 缓存一般使用思路简介\r\n\r\n![image-20241115103837372](assets/image-20241115103837372.png)\r\n\r\n1. 客户端请求服务\r\n2. 服务去redis试着拿取数据。\r\n3. redis将数据返回给服务，如果返回的结果有数据则执行上图第七步，如果没有数据则继续向下执行。\r\n4. 服务从数据库中查询数据。\r\n5. 数据库将查询结果返回给服务。\r\n6. 数据库返回数据则添加到redis中。\r\n7. 请求数据返回给客户端。\r\n\r\n## 2. 缓存穿透\r\n\r\n![image-20241115105231198](assets/image-20241115105231198.png)\r\n\r\n### 2.1 描述\r\n\r\n通过接口访问一个缓存和数据库都不存在的数据。\r\n\r\n服务出于容错考虑，当请求从持久层查不到数据则不写入缓存，这将导致请求这个不存在的数据每次都要到持久层去查询，失去了缓存的意义。此时，缓存起不到保护后端持久层的意义，就像被穿透了一样。导致数据库存在被打挂的风险。\r\n\r\n### 2.2 解决方案\r\n\r\n1.接口请求参数的校验。对请求的接口进行鉴权，数据合法性的校验等；比如查询的userId不能是负值或者包含非法字符等。\r\n\r\n2.当数据库返回空值时，将空值缓存到redis，并设置合理的过期时间。\r\n\r\n3.**布隆过滤器**。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。\r\n\r\n## 3. 缓存击穿\r\n\r\n![image-20241115132125907](assets/image-20241115132125907.png)\r\n\r\n### 3.1 描述\r\n\r\n某个热点 key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，导致数据库存在被打挂的风险。\r\n\r\n### 3.2 解决方案\r\n\r\n1.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。\r\n\r\n2.设置缓存不过期或者后台有线程一直给热点数据续期。\r\n\r\n\r\n\r\n## 4. 缓存雪崩\r\n\r\n![image-20241115132540596](assets/image-20241115132540596.png)\r\n\r\n### 4.1 描述\r\n\r\n大量的热点数据过期时间相同，导致数据在同一时刻集体失效。造成瞬时数据库请求量大、压力骤增，引起雪崩，导致数据库存在被打挂的风险。\r\n\r\n### 4.2 解决方案\r\n\r\n1.**将热点数据的过期时间打散**。给热点数据设置过期时间时加个随机值。\r\n\r\n2.加互斥锁。当热点key过期后，大量的请求涌入时，只有第一个请求能获取锁并阻塞，此时该请求查询数据库，并将查询结果写入redis后释放锁。后续的请求直接走缓存。\r\n\r\n3.设置缓存不过期或者后台有线程一直给热点数据续期。","excerpt":"","includedFiles":[],"tasklists":0,"title":"Redis缓存击穿-穿透-雪崩","headers":[{"level":2,"title":"1. 缓存一般使用思路简介","slug":"_1-缓存一般使用思路简介","link":"#_1-缓存一般使用思路简介","children":[]},{"level":2,"title":"2. 缓存穿透","slug":"_2-缓存穿透","link":"#_2-缓存穿透","children":[{"level":3,"title":"2.1 描述","slug":"_2-1-描述","link":"#_2-1-描述","children":[]},{"level":3,"title":"2.2 解决方案","slug":"_2-2-解决方案","link":"#_2-2-解决方案","children":[]}]},{"level":2,"title":"3. 缓存击穿","slug":"_3-缓存击穿","link":"#_3-缓存击穿","children":[{"level":3,"title":"3.1 描述","slug":"_3-1-描述","link":"#_3-1-描述","children":[]},{"level":3,"title":"3.2 解决方案","slug":"_3-2-解决方案","link":"#_3-2-解决方案","children":[]}]},{"level":2,"title":"4. 缓存雪崩","slug":"_4-缓存雪崩","link":"#_4-缓存雪崩","children":[{"level":3,"title":"4.1 描述","slug":"_4-1-描述","link":"#_4-1-描述","children":[]},{"level":3,"title":"4.2 解决方案","slug":"_4-2-解决方案","link":"#_4-2-解决方案","children":[]}]}]}}
