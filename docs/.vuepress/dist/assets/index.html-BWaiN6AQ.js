import{_ as t,c as a,a as o,o as n}from"./app-CpFzMANX.js";const r="/assets/image-20240710102649394-D_gNI41m.png",i="/assets/image-20240710111406345-Cvze-XEL.png",c="/assets/image-20240710123807058-B4vyMjS4.png",d="/assets/image-20240710132559964-DwW_Ciy2.png",s="/assets/image-20240710133326729-D4R2rky6.png",p="/assets/image-20240710141351877-CeKw-gvU.png",l={};function h(g,e){return n(),a("div",null,e[0]||(e[0]=[o('<h1 id="docker-网络" tabindex="-1"><a class="header-anchor" href="#docker-网络"><span>Docker 网络</span></a></h1><p>网络模式：</p><table><thead><tr><th>网络模式</th><th>简介</th><th>指定方式</th></tr></thead><tbody><tr><td>bridge</td><td>为每个容器分配、设置IP等，并将容器连接到一个叫做docker0的虚拟网桥，默认为该模式</td><td>--network bridge</td></tr><tr><td>host</td><td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</td><td>--network host</td></tr><tr><td>none</td><td>容器有独立的Network namespace,但并没有对其进行任何网络设置，如分配veth pair和网桥连接，IP等</td><td>--network none</td></tr><tr><td>container</td><td>新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP,端口范围</td><td>--network container:name或者容器id</td></tr></tbody></table><div class="hint-container note"><p class="hint-container-title">注</p><ol><li>查看网络模式：docker netword ls</li><li>查看网络模式详情： docker inspect network bridge/host/自定义网络模式</li><li>查看容器网络：docker inspect 容器name或容器id</li></ol></div><h2 id="_1-bridge" tabindex="-1"><a class="header-anchor" href="#_1-bridge"><span>1. bridge</span></a></h2><p><strong>Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称就是docker0,它在内核层联通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放在了同一个物理网络。Docker默认指定了docker0接口的ip地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</strong></p><h3 id="_1-1-虚拟网桥" tabindex="-1"><a class="header-anchor" href="#_1-1-虚拟网桥"><span>1.1 虚拟网桥</span></a></h3><p>当启动docker时会产生一个名字为docker0的虚拟网桥</p><figure><img src="'+r+'" alt="image-20240710102649394" tabindex="0" loading="lazy"><figcaption>image-20240710102649394</figcaption></figure><p>docker就是通过docker0这个虚拟网桥和宿主机之间以及容器和容器之间进行网络通信的。</p><p><strong>测试镜像： docker run -d -p 8083:8080 --name tomcat83 billygoo/tomcat8-jdk8</strong></p><h3 id="_1-2-模型" tabindex="-1"><a class="header-anchor" href="#_1-2-模型"><span>1.2. 模型</span></a></h3><figure><img src="'+i+'" alt="image-20240710111406345" tabindex="0" loading="lazy"><figcaption>image-20240710111406345</figcaption></figure><ol><li><p>整个宿主机的网桥模式都是docker0,类似于一个交换机有一堆接口，每个接口叫veth,在本地主机和容器内分别创建一个虚拟接口，并让他们彼此之间可以联通（这样一对接口叫做veth pair）</p></li><li><p>每个容器实例内部也有一块网卡，每个接口叫做eth0;</p></li><li><p>docker0上面的每个veth匹配某个容器实例内部的eth0,两两配对、一一匹配。</p><div class="hint-container note"><p class="hint-container-title">注</p><p>综述：将宿主机上的所有容器都连接到这个内部网络上，两个容器在同一个网络下，会从这个网关下拿到各自分配的ip,此时两个容器之间的网络是相通的。</p></div></li></ol><h2 id="_2-host" tabindex="-1"><a class="header-anchor" href="#_2-host"><span>2. host</span></a></h2><blockquote><p>=== 直接使用宿主机的IP地址与外界进行通信，不再需要额外的进行NAT转换.</p></blockquote><p><strong>测试镜像： docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</strong></p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>docker 启动时如果指定了 -p 映射端口，会出现警告。</p><p>host 模式下 -p 指定的端口将不会起到任何作用，端口号会以主机端口号为主。重复时则递增。</p></div><h3 id="_2-1-模型" tabindex="-1"><a class="header-anchor" href="#_2-1-模型"><span>2.1 模型</span></a></h3><figure><img src="'+c+'" alt="image-20240710123807058" tabindex="0" loading="lazy"><figcaption>image-20240710123807058</figcaption></figure><p>容器将不会获得一个独立的Network Namespace,而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，而是使用宿主机的IP和端口。</p><h2 id="_3-none" tabindex="-1"><a class="header-anchor" href="#_3-none"><span>3. none</span></a></h2><blockquote><p>=== 禁用了网络功能，只有lo标识（就是127.0.0.1标识本地回环）</p></blockquote><figure><img src="'+d+'" alt="image-20240710132559964" tabindex="0" loading="lazy"><figcaption>image-20240710132559964</figcaption></figure><div class="hint-container note"><p class="hint-container-title">注</p><p>在none模式下，并不为Docker容器进行任何的网络配置</p><p>Docker容器没有网卡、IP、路由配置等信息，只有lo</p></div><h2 id="_4-container" tabindex="-1"><a class="header-anchor" href="#_4-container"><span>4. container</span></a></h2><blockquote><p>=== 新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定容器共享IP、端口范围等。</p><p>两个容器除了网络方面，其它的如文件系统、进程列表等还是隔离的。</p></blockquote><h3 id="_4-1-模型" tabindex="-1"><a class="header-anchor" href="#_4-1-模型"><span>4.1 模型</span></a></h3><figure><img src="'+s+'" alt="image-20240710133326729" tabindex="0" loading="lazy"><figcaption>image-20240710133326729</figcaption></figure><p><strong>docker run -d --network container:tomcat81 --name tomcat82 billygoo/tomcat8-jdk8</strong></p><p>这里如果两个容器都是tomcat不适合，因为8080端口会产生冲突。</p><h2 id="_5-自定义网络模式" tabindex="-1"><a class="header-anchor" href="#_5-自定义网络模式"><span>5. 自定义网络模式</span></a></h2><blockquote><p>=== 可以保证容器之间通过服务名访问</p><p>！！！！！ 自定义网络本身就维护好了主机名和ip的对应关系，ip和域名都能通</p></blockquote><h3 id="_5-1-新建自定义网络" tabindex="-1"><a class="header-anchor" href="#_5-1-新建自定义网络"><span>5.1 新建自定义网络</span></a></h3><p>docker network create test_network</p><h3 id="_5-2-新建容器" tabindex="-1"><a class="header-anchor" href="#_5-2-新建容器"><span>5.2 新建容器</span></a></h3><p>docker run -d -p 8081:8080 --network test_network --name tomcat81 billygoo/tomcat8-jdk8</p><p>docker run -d -p 8082:8080 --network test_network --name tomcat82 billygoo/tomcat8-jdk8</p><h3 id="_5-3-通过服务名测试服务通信" tabindex="-1"><a class="header-anchor" href="#_5-3-通过服务名测试服务通信"><span>5.3 通过服务名测试服务通信</span></a></h3><figure><img src="'+p+'" alt="image-20240710141351877" tabindex="0" loading="lazy"><figcaption>image-20240710141351877</figcaption></figure><h2 id="_6-主要用途" tabindex="-1"><a class="header-anchor" href="#_6-主要用途"><span>6. 主要用途</span></a></h2><ol><li>容器之间的互联和通信以及端口映射</li><li>容器IP变动时可以通过服务名连接网络通信而不受影响</li></ol>',42)]))}const m=t(l,[["render",h],["__file","index.html.vue"]]),_=JSON.parse('{"path":"/notes/Docker/network/","title":"Docker 网络","lang":"zh-CN","frontmatter":{"description":"Docker 网络 网络模式： 注 查看网络模式：docker netword ls 查看网络模式详情： docker inspect network bridge/host/自定义网络模式 查看容器网络：docker inspect 容器name或容器id 1. bridge Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称...","head":[["meta",{"property":"og:url","content":"https://kylinBachelor.github.io/notes/Docker/network/"}],["meta",{"property":"og:site_name","content":"攻城狮"}],["meta",{"property":"og:title","content":"Docker 网络"}],["meta",{"property":"og:description","content":"Docker 网络 网络模式： 注 查看网络模式：docker netword ls 查看网络模式详情： docker inspect network bridge/host/自定义网络模式 查看容器网络：docker inspect 容器name或容器id 1. bridge Docker 服务默认会创建一个docker0的虚拟网桥，该桥接网络的名称..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-30T10:36:56.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-30T10:36:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker 网络\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-30T10:36:56.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.64,"words":1093},"git":{"updatedTime":1732963016000},"autoDesc":true,"filePathRelative":"notes/Docker/network/index.md","categoryList":[{"id":"4358b5","sort":10025,"name":"notes"},{"id":"7acc78","sort":10039,"name":"Docker"},{"id":"a1f1a3","sort":10069,"name":"network"}],"bulletin":false}');export{m as comp,_ as data};
