import{_ as a,c as t,a as i,o as l}from"./app-CpFzMANX.js";const n={};function o(r,e){return l(),t("div",null,e[0]||(e[0]=[i('<h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h2><ol><li>降低类的复杂度，一个类只负责一项职责。</li><li>提高类的可读性，可维护性。</li><li>降低变更引起的风险。</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中的方法数量足够少，可以在方法级别保持单一职责原则。</li></ol><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h2><ol><li>客户端不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li><li>尽可能避免不需要的方法的出现</li></ol><h2 id="依赖倒转-倒置-原则" tabindex="-1"><a class="header-anchor" href="#依赖倒转-倒置-原则"><span>依赖倒转（倒置）原则</span></a></h2><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖其细节，细节应该依赖抽象。</li><li>依赖倒置的中心思想是面向接口编程。</li><li>设计理念是：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多，Java中，抽象指的是接口或者抽象类，细节就是具体的实现类。</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li></ol><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h2><ol><li>在使用继承时，在子类中尽量不要重写父类方法</li><li>继承实际上让两个类耦合性增强了，在适当情况下，可以通过聚合，组合，依赖来解决问题</li></ol><h2 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h2><ol><li>开闭原则时编程中最基础，最重要的设计原则。</li><li>一个软件实体，如类，模块和函数应该对扩展开放（提供方），对修改关闭（对使用方），用抽象构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改自己的代码来实现变化。</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><h2 id="迪米特法则" tabindex="-1"><a class="header-anchor" href="#迪米特法则"><span>迪米特法则</span></a></h2><ol><li>一个对象应该对其它对象保持最少的了解。</li><li>类与类关系越密切，耦合度越大。</li><li>一个类对自己依赖的类知道的越少越好。对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息</li><li>只与直接的朋友（出现成员变量，方法参数，方法返回值中的类为直接朋友，出现在局部变量中的类不是直接朋友）通信</li></ol><h2 id="合成复用原则" tabindex="-1"><a class="header-anchor" href="#合成复用原则"><span>合成复用原则</span></a></h2><ol><li>原则是尽量使用 <strong>合成/聚合</strong> 的方式，而不是使用 <strong>继承</strong> 。</li></ol><h2 id="设计原则的核心思想" tabindex="-1"><a class="header-anchor" href="#设计原则的核心思想"><span>设计原则的核心思想</span></a></h2><ol><li>找出应用中可能变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力。</li></ol>',16)]))}const d=a(n,[["render",o],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","title":"设计原则","lang":"zh-CN","frontmatter":{"title":"设计原则","aliases":null,"tags":["设计模式"],"description":"设计原则","createTime":"2024/11/30 14:15:41","draft":false,"head":[["meta",{"property":"og:url","content":"https://kylinBachelor.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"}],["meta",{"property":"og:site_name","content":"攻城狮"}],["meta",{"property":"og:title","content":"设计原则"}],["meta",{"property":"og:description","content":"设计原则"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-30T10:36:56.000Z"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:modified_time","content":"2024-11-30T10:36:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-30T10:36:56.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":2.84,"words":853},"git":{"updatedTime":1732963016000},"filePathRelative":"notes/设计模式/设计原则/index.md","categoryList":[{"id":"4358b5","sort":10025,"name":"notes"},{"id":"ff2bbb","sort":10026,"name":"设计模式"},{"id":"ce1d66","sort":10120,"name":"设计原则"}],"bulletin":false}');export{d as comp,c as data};
